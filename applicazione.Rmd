---
title: "Presentazione"
author: "Enrico Cominato"
date: "11 febbraio 2019"
output: 
  html_notebook
runtime: shiny
---

<style>
  .col2 {
    columns: 2 200px;         /* number of columns and width in pixels*/
    -webkit-columns: 2 200px; /* chrome, safari */
    -moz-columns: 2 200px;    /* firefox */
  }
  .col3 {
    columns: 3 100px;
    -webkit-columns: 3 100px;
    -moz-columns: 3 100px;
  }
  .shiny-input-checkboxgroup.shiny-input-container-inline label ~ .shiny-options-group, .shiny-input-radiogroup.shiny-input-container-inline label ~ .shiny-options-group {
    margin-top: -1px;
    margin-left: auto;
    margin-right: auto;
    width: 800px !important;
  }
  .irs{
    width: 800px !important;
  }
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(tidyverse)
library(igraph)
#library(corrplot)
# per caricare
#library(rsconnect)
#rsconnect::deployApp('applicazione.Rmd')

# per stampe e filtri vari
classi <- c("Druid", 
            "Hunter", 
            "Mage",
            "Paladin",
            "Priest",
            "Rogue",
            "Shaman",
            "Warlock",
            "Warrior")

carte_da_escludere <- c("The Coin",
                        "Shapeshift"      , "Dire Shapeshift",   
                        "Steady Shot"     , "Ballista Shot",
                        "Fireblast"       , "Fireblast Rank 2",
                        "Reinforce"       , "The Silver Hand",
                        "Lesser Heal"     , "Heal",
                        "Dagger Mastery"  , "Poisoned Daggers",
                        "Totemic Call"    , "Totemic Slam",
                        "Life Tap"        , "Soul Tap",
                        "Armor Up!"       , "Tank Up!" )

colori <- c("Druid"="brown", 
            "Hunter"="green", 
            "Mage"="aquamarine",
            "Paladin"="yellow",
            "Priest"="grey",
            "Rogue"="black",
            "Shaman"="blue",
            "Warlock"="blueviolet",
            "Warrior"="red")

icone <- c(
  "https://hsreplay.net/static/images/class-icons/druid.png",
  "https://hsreplay.net/static/images/class-icons/hunter.png",
  "https://hsreplay.net/static/images/class-icons/mage.png",
  "https://hsreplay.net/static/images/class-icons/paladin.png",
  "https://hsreplay.net/static/images/class-icons/priest.png",
  "https://hsreplay.net/static/images/class-icons/rogue.png",
  "https://hsreplay.net/static/images/class-icons/shaman.png",
  "https://hsreplay.net/static/images/class-icons/warlock.png",
  "https://hsreplay.net/static/images/class-icons/warrior.png"
)

# dataset delle partite fatte
dataset_games <- read_csv("dataset/games.csv")

# preferisco:
# 1: spaccare data e ora
# 2: mettere il risultato della partita come un booleano
# 3: trasformo il rank in un valore intero
games <- dataset_games %>%
  mutate(period = as.Date(added,format = "%Y-%m") ) %>%
  mutate(result = if_else(result=="win", TRUE, FALSE)) %>%
  mutate(coin = if_else(coin=="true", TRUE, FALSE)) %>%
  transform(rank = as.numeric(rank))%>%
  transform(legend = as.numeric(legend))%>%
  select(everything() , -added)

# dataset delle giocate fatte in ogni partita
dataset_plays <- read_csv("dataset/plays.csv")

# Da rimuovere
#    card_id              name tot
# 1  AT_042t Sabertooth Lion     2
# 2 AT_042t2 Sabertooth Panther  2
# 3 AT_042t2 Druid of the Saber  2
# 4  AT_042t Druid of the Saber  2
plays <- dataset_plays %>%
  filter(turn > 0 & 
         !(card_id=="AT_042t2" | name=="Sabertooth Lion") &
         !(name %in% carte_da_escludere)
         ) %>%
  transform(mana = as.numeric(mana))%>%
  mutate(mana = if_else(is.na(mana), 0, mana)) %>%
  left_join(games , by = c("game_id"="id"))%>%
  select(game_id, period, player, turn, card_id, name, mana)

# periodo di validit√† del dataset
start <- (games %>%
  select(period) %>%
  group_by(period) %>%
  arrange(period) %>%
  head(1) )[[1]]

end <- (games %>%
  select(period) %>%
  group_by(period) %>%
  arrange(desc(period)) %>%
  head(1))[[1]]

filter_by_date <- function(ds,range ){
return( ds %>%
          filter(
            between(as.Date(period,"%Y-%m"),
                    as.Date(range[1],"%Y-%m"),
                    as.Date(range[2],"%Y-%m")
                    ) 
          )
      )
}
filter_by_class <- function(ds,selector){
  # se non ho selezionato una classe le ritorno tutte
  if (is.null(selector) ){ return(ds) }
  # seleziono solo le classi scelte
  return( ds %>%
    filter( class %in% selector )
  )
}

top <- function(list,n){
  return( head(sort(list, decreasing = TRUE),n) )
}
```
## Introduction

In this presentation we will analize the card game Hearthsone.
- We will see how the "meta" has changed through the years, which decks have been played and we will try to figure out why they haev been played.
- After that, there will be an analysis of each single card used in the game not only the frequency of usage during time but also we will try to figure out how a single card can have an impact on the game.
- At the end there will be "mithbuster time" were we try to find if tips and advise from pro player are really useful or just mith.

All the data are available [here](http://www.hearthscry.com/). Here we have loaded data from `r start` to `r end`.

## First analysis
Let's prepare the data. **TESTO DA FARE**

```{r class winrate computation, echo=TRUE}
# class winrate
class_hero <- games %>%
  group_by(hero, period) %>%
  summarize(wins = sum(result), games = n()) %>%
  rename(class = hero) %>%
  ungroup()

class_oppo <- games %>%
  group_by(opponent, period) %>%
  summarize(wins = sum(result), games = n()) %>%
  rename(class = opponent) %>%
  ungroup()

class_total <- class_hero %>%
  left_join(class_oppo, by = c("class", "period")) %>%
  group_by(class, period) %>%
  summarize(wins = wins.x+wins.y, games = games.x+games.y, winrate = wins/games)
```

Here we have an example of the resulting data of the last day. **TESTO DA FARE**
```{r class winrate table view, echo=FALSE}
class_total$class <- as.factor(class_total$class)
# vediamo i dati
knitr::kable(
  class_total %>% filter(period == end), 
  caption = "Class winrate over time"
)

```

## Guardiamo un po' il winrate di ogni classe {#title .emphasized }

We can select one or more classes (if none there will be displayed all)
    
```{r}
inputPanel(
  checkboxGroupInput("class_selector", "Classi",
    choiceNames = mapply(classi, icone, FUN = function(classe, iconeUrl) {
      tagList(
        tags$img(src=iconeUrl, width=50, height=50),
        ""
      )
    }, SIMPLIFY = FALSE, USE.NAMES = FALSE),
    choiceValues = classi,
    inline = TRUE
  ),
  textOutput("txt")
)
```
And we can select a specific period of time.

```{r}
inputPanel(
#Add a Slider Input to select date range
  sliderInput(inputId = "Date_range_selector",
             label ="Select Date Range",
             min = start,
             max = end,
             value = c(start,end),
             step = 30,
             timeFormat="%Y-%m")
)
```   
 
So, this is our winrate for each class...but this is not tellig us a lot.
In the next step we'll try to find out why a specific class has that winrate in that period.
    
```{r}
renderPlot({
  class_total %>%
    filter_by_date(input$Date_range_selector)%>%
      filter_by_class(input$class_selector)%>%
        ggplot(aes(x = period, y = winrate)) + 
          geom_smooth(aes(color = factor(class)), se = FALSE) +
            scale_color_manual( values = colori)
})
```
## Presence on the game {#title .emphasized }
First of all we want to know if the number of player that use a specific class can influence the meta. So we plot the number of games per class.

```{r presence computation}
class_total <- class_total %>%
  group_by(period) %>%
  mutate(total_games_per_day = sum(games)) %>%
  ungroup() %>%
  mutate(presence = games/total_games_per_day)

# vediamo i dati
knitr::kable(
  class_total %>% filter(period == end), 
  caption = "Class winrate over time"
)
```

As before, We can select one or more classes (if none there will be displayed all) and a specific period of time.
    
```{r}
inputPanel(
  checkboxGroupInput("presence_class_selector", "Classi",
    choiceNames = mapply(classi, icone, FUN = function(classe, iconeUrl) {
      tagList(
        tags$img(src=iconeUrl, width=50, height=50),
        ""
      )
    }, SIMPLIFY = FALSE, USE.NAMES = FALSE),
    choiceValues = classi,
    inline = TRUE
  )
)

inputPanel(
#Add a Slider Input to select date range
  sliderInput(inputId = "presence_Date_range_selector",
             label ="Select Date Range",
             min = start,
             max = end,
             value = c(start,end),
             step = 30,
             timeFormat="%Y-%m")
)
```

```{r presence plot}
renderPlot({
  class_total %>%
    filter_by_date(input$presence_Date_range_selector)%>%
      filter_by_class(input$presence_class_selector)%>%
        ggplot(aes(x = period, y = presence)) + 
          geom_smooth(aes(color = factor(class)), se = FALSE) +
            scale_color_manual( values = colori)
})
```
What is the correlation between the number of player that are using a specific class and his winrate?

```{r}
inputPanel(
#Add a Slider Input to select date range
  sliderInput(inputId = "correlation_Date_range_selector",
             label ="Select Date Range",
             min = start,
             max = end,
             value = c(start,end),
             step = 30,
             timeFormat="%Y-%m")
)
``` 

```{r correlation presence winrate plot}
renderPlot({
  class_total %>%
    filter_by_date(input$correlation_Date_range_selector)%>%
    mutate(total_games_period_selected = sum(games))%>%
    group_by(class,total_games_period_selected)%>%
    summarize(games_per_period = sum(games),
              wins_per_period  = sum(wins))%>%
    # quante partite registrate di quella classe sul totale delle partite di tutte le classi
    mutate(presence_per_period = games_per_period/total_games_period_selected,
    # quante vittorie registrate di quella classe sul totale delle partite di quella classe
              winrate_per_period = wins_per_period/games_per_period) %>%
    select(class, wins_per_period,games_per_period,presence_per_period,winrate_per_period) %>%

    # plot dei risultati
    ggplot(aes(x = presence_per_period, y = winrate_per_period),show.legend = FALSE) +  
    geom_point(aes(color = factor(class), size = 16*winrate_per_period, stroke = 5),show.legend = FALSE) +
    scale_color_manual( values = colori)+
    ylim(0.3 ,0.75) + 
    xlim(0.  ,0.3)
})
```

This seems not really helpful. And if we focus only on high ranks? 
## Winrate filtered on high ranks {#title .emphasized }

```{r class winrate computation with rank, echo=TRUE}
# class winrate
class_hero_rank <- games %>%
  filter(rank <=5 | legend > 0 ) %>%
  group_by(hero, period) %>%
  summarize(wins = sum(result), games = n()) %>%
  rename(class = hero) %>%
  ungroup()

class_oppo_rank <- games %>%
  filter(rank <=5 | legend > 0 ) %>%
  group_by(opponent, period) %>%
  summarize(wins = sum(result), games = n()) %>%
  rename(class = opponent) %>%
  ungroup()

class_total_rank <- class_hero_rank %>%
  left_join(class_oppo_rank, by = c("class", "period")) %>%
  group_by(class, period) %>%
  summarize(wins = wins.x+wins.y, games = games.x+games.y, winrate = wins/games) %>%
  ungroup()
```

```{r rank input}
inputPanel(
  checkboxGroupInput("rank_class_selector", "Classi",
    choiceNames = mapply(classi, icone, FUN = function(classe, iconeUrl) {
      tagList(
        tags$img(src=iconeUrl, width=50, height=50),
        ""
      )
    }, SIMPLIFY = FALSE, USE.NAMES = FALSE),
    choiceValues = classi,
    inline = TRUE
  )
)

inputPanel(
#Add a Slider Input to select date range
  sliderInput(inputId = "rank_Date_range_selector",
             label ="Select Date Range",
             min = start,
             max = end,
             value = c(start,end),
             step = 30,
             timeFormat="%Y-%m")
)
``` 

```{r rank winrate plot}
renderPlot({
  class_total_rank %>%
    filter_by_date(input$rank_Date_range_selector)%>%
      filter_by_class(input$rank_class_selector)%>%
        ggplot(aes(x = period, y = winrate)) + 
          geom_smooth(aes(color = factor(class)), se = FALSE) +
            scale_color_manual( values = colori)
})
```

Does we have any changes looking to the correlation between the number of player that are using a specific class and his winrate?

```{r}
inputPanel(
#Add a Slider Input to select date range
  sliderInput(inputId = "rank_correlation_Date_range_selector",
             label ="Select Date Range",
             min = start,
             max = end,
             value = c(start,end),
             step = 30,
             timeFormat="%Y-%m")
)
``` 

```{r rank correlation presence winrate plot}
renderPlot({
  class_total_rank %>%
    filter_by_date(input$rank_correlation_Date_range_selector)%>%
    mutate(total_games_period_selected = sum(games,  na.rm = TRUE))%>%
    group_by(class,total_games_period_selected)%>%
    summarize(games_per_period = sum(games,  na.rm = TRUE),
              wins_per_period  = sum(wins ,  na.rm = TRUE))%>%
    # quante partite registrate di quella classe sul totale delle partite di tutte le classi
    mutate(presence_per_period = games_per_period/total_games_period_selected,
    # quante vittorie registrate di quella classe sul totale delle partite di quella classe
           winrate_per_period  = wins_per_period/games_per_period) %>%
    select(class, wins_per_period,games_per_period,presence_per_period,winrate_per_period)%>%
  

    # plot dei risultati
    ggplot(aes(x = presence_per_period, y = winrate_per_period),show.legend = FALSE) +  
    geom_point(aes(color = factor(class), size = 16*winrate_per_period, stroke = 5),show.legend = FALSE) +
    scale_color_manual( values = colori)+
    ylim(0.3 ,0.75) + 
    xlim(0.  ,0.3)
})
```



## correlation
Let's analyze the correlation between the winrate of different classes and see if we can understand somenthing more from the information about the presence of those classes in the game

```{r winrate correlation computation}
winrate_correlation <- class_total %>% select(period)

winrate_correlation <- class_total  %>% 
  filter(class=="Druid") %>%
  right_join(winrate_correlation, by = "period") %>%
  mutate("Druid winrate" = winrate) %>%
  select(period, `Druid winrate`)
  
winrate_correlation <- class_total  %>% 
  filter(class=="Priest") %>%
  right_join(winrate_correlation, by = "period") %>%
  mutate("Priest winrate" = winrate) %>%
  select(period, `Druid winrate`, `Priest winrate`)

winrate_correlation <- class_total  %>% 
  filter(class=="Rogue") %>%
  right_join(winrate_correlation, by = "period") %>%
  mutate("Rogue winrate" = winrate) %>%
  select(period, `Druid winrate`, `Priest winrate`, `Rogue winrate`)

winrate_correlation <- class_total  %>% 
  filter(class=="Mage") %>%
  right_join(winrate_correlation, by = "period") %>%
  mutate("Mage winrate" = winrate) %>%
  select(period, `Druid winrate`, `Priest winrate`, `Rogue winrate`, `Mage winrate`)

winrate_correlation <- class_total  %>% 
  filter(class=="Shaman") %>%
  right_join(winrate_correlation, by = "period") %>%
  mutate("Shaman winrate" = winrate) %>%
  select(period, `Druid winrate`, `Priest winrate`, `Shaman winrate`, `Rogue winrate`, `Mage winrate`)

winrate_correlation <- class_total  %>% 
  filter(class=="Warlock") %>%
  right_join(winrate_correlation, by = "period") %>%
  mutate("Warlock winrate" = winrate) %>%
  select(period, `Druid winrate`, `Priest winrate`, `Shaman winrate`, `Rogue winrate`, `Mage winrate`, `Warlock winrate`)

winrate_correlation <- class_total  %>% 
  filter(class=="Warrior") %>%
  right_join(winrate_correlation, by = "period") %>%
  mutate("Warrior winrate" = winrate) %>%
  select(period, `Druid winrate`, `Priest winrate`, `Shaman winrate`, `Rogue winrate`, `Mage winrate`, `Warlock winrate`, `Warrior winrate`)

winrate_correlation <- class_total  %>% 
  filter(class=="Paladin") %>%
  right_join(winrate_correlation, by = "period") %>%
  mutate("Paladin winrate" = winrate) %>%
  select(period, `Druid winrate`, `Priest winrate`, `Shaman winrate`, `Rogue winrate`, `Mage winrate`, `Warlock winrate`, `Warrior winrate`, `Paladin winrate`)

winrate_correlation <- class_total  %>% 
  filter(class=="Hunter") %>%
  right_join(winrate_correlation, by = "period") %>%
  mutate("Hunter winrate" = winrate) %>%
  select(period, `Druid winrate`, `Priest winrate`, `Shaman winrate`, `Rogue winrate`, `Mage winrate`, `Warlock winrate`, `Warrior winrate`, `Paladin winrate`, `Hunter winrate`)

# vediamo i dati
knitr::kable(
  head(winrate_correlation,10), 
  caption = "Class winrate over time"
)
```

## Card Analysis
```{r cards}
filtered_plays <- plays %>%
  left_join(games%>%select(id,result,rank,legend), by = c("game_id"="id"))%>%
  filter(period==end)%>%
  filter(rank<=5 | legend >0)

nodes <- filtered_plays %>%
  group_by(name)%>%
  summarize(avg_turn = mean(turn), 
            mana=mean(mana) )%>%
  ungroup()%>%
  select(name,mana,avg_turn)%>%
  arrange(avg_turn)

card_name1 <- character()
card_name2 <- character()
#way = logical()
old_me <- "fake"
old_op <- "fake"

total <- length(filtered_plays$game_id)
total_edges <- 1
for( i in (2:total)){
  row1 = filtered_plays[i-1, ]
  row2 = filtered_plays[i  , ]
  # se sono due giocate successive della stessa partita le lego tra loro
  if (row1$game_id == row2$game_id) {
    if (row1$player == row2$player) {
      # se sono due giocate dello stesso giocatore
      card_name1[[total_edges]]<- row1$name
      card_name2[[total_edges]]<- row2$name
    } else if (row1$player == "me"){
      if (old_me=="fake"){ old_me <- row2$name }
      else{
        card_name1[[total_edges]]<- old_me
        card_name2[[total_edges]]<- row2$name
        old_me                   <- row2$name
      }
    } else if (row1$player == "opponent"){
      if (old_op=="fake"){ old_op <- row2$name }
      else{
        card_name1[[total_edges]]<- old_op
        card_name2[[total_edges]]<- row2$name
        old_op                   <- row2$name
      }
    }
    total_edges = total_edges + 1
  }
}

edges <- tibble(
  card_1 = card_name1, 
  card_2 = card_name2)
  #ways     = way[2:total] )


# tengo conto di quante volte viene fatta la stessa giocata
edges <- edges %>%
  filter(!is.na(card_1) & !is.na(card_2)) %>%
  group_by(card_1,card_2)%>%
  summarize(weight = n())


# controlliamo che sia tutto apposto
#temp <- edges %>%
#  anti_join(nodes , by = c("card_1"="name")) %>%
#  anti_join(nodes , by = c("card_2"="name"))

g = graph_from_data_frame(edges, directed = TRUE, vertices = nodes)
v_color <- rep("grey40", vcount(g))
l = layout_with_kk(g)*1.2
plot(g, layout=l, edge.width = edges$weight, vertex.label=NA,  vertex.color=v_color)
```

Let's analyze this network!!
First of all...which are the most versatile cards? They are such cards which lies in lot of path...so those with highest betweeness.
```{r betweenness, echo=TRUE}
belli = top(betweenness(g), 10)
belli
v_color[belli] <- "#ff9d00"
plot(g, layout=layout_with_kk, edge.width = edges$weight, vertex.label=NA,  vertex.color=v_color)
```

When we have to build a deck and we miss a card...which are the best replacements? 

```{r similarity, echo=TRUE}
s <- similarity(g)
head(s)
```

Which are the most powerful cards?

```{r power, echo=TRUE}
forti = top(power_centrality(g),10)
v_color <- rep("grey40", vcount(g))
v_color[forti] <- "#ff9d00"
plot(g, layout=layout_with_kk, edge.width = edges$weight, vertex.label=NA,  vertex.color=v_color)
```

Can we identify combos?

```{r components, echo=TRUE}
components = components(g)
components
components = biconnected_components(g)
components
v_color <- rep("grey40", vcount(g))
v_color[forti] <- "#ff9d00"
plot(g, layout=layout_with_kk, edge.width = edges$weight, vertex.label=NA,  vertex.color=v_color)
```